/// 我们并不关系寄存器是 32 位的还是 64 为的,这由 Bus::cache 的具体实现决定
pub trait Register {
    type CacheType;
}

/// bus 可以是内存数据总线，也可以是外围通信总线。
/// 将寄存器作为 trait 参数，这样在实现的时候可以为具体的寄存器定制读写方式。
/// 如果寄存器有通用的 cache 方式，则可以另行实现（定义）具体 Bus 相关的寄存器 trait，如 I2cReg.
///
/// 对于寄存器，可以将其看作一个和硬件共享的全局变量。
/// 非原子访问全局变量是一个非常危险的事，但是寄存器数量众多，如果每一个都要求原子访问是非常浪费资源的。
/// 并且有些寄存器会被频繁访问。
///
/// 因此在底层访问上提供安全访问的手段并不是一个明智的选择。
/// 需要上层按模块提供安全访问的手段。比如某一个硬件模块的寄存器实际上只会在上层软件的某一个模块访问。
/// 这一模块整体可能会被其他模块共享，我们对外提供该模块的原子访问策略即可。
/// 我们需要一个 macro，去辅助定义这样的 bus
/// ```
/// #[mmio(0x100)]
/// pub struct I2CProfile {
///     #[offset(0x4)]
///     pub Reg1: Reg1Cache;
///
///     #[offset(0x8)]
///     pub Reg2: Reg2Cache;
/// }
/// ```
/// 这里我们我们需要生成 Reg1 和 Reg2 寄存器。
/// 这种方式，我们也很好的规定了 I2CProfile 和其所拥有的寄存器之间的所属关系。
/// 上面的实例针对的是 MMIO 寄存器，当然无法覆盖大部分情况。有些 MMIO 会有地址重映射，base 不是一个固定的值，
/// 这时候需要用户自行实现 base 函数。
///
/// 如果无法覆盖用户的案例，则用户还需要自行实现类似的宏，以减轻工作量。
///
/// 有些寄存器其 CacheType 都是一样的，如 Gpio 组。
/// 则可以使用如下范式：
/// ```
/// struct Gpio(u32);
/// let pin3 = Profile::cache(Gpio(3));
/// ```
/// profile 实际上是一中分组方式。
pub trait Profile<T: Register> {
    /// cache 是不安全的，因为获取的值可能和实际上的实时值不一至。这也是为什么该操作称为 cache。
    unsafe fn cache(reg: T) -> T::CacheType;
    unsafe fn flush(reg: T, cache: T::CacheType);
}
